const mongoose = require('mongoose');

/**
 * ‚≠ê –ú–û–î–ï–õ–¨ –û–¢–ó–´–í–ê
 * –°–∏—Å—Ç–µ–º–∞ –æ—Ç–∑—ã–≤–æ–≤ —Å –º–æ–¥–µ—Ä–∞—Ü–∏–µ–π –∏ —Ä–µ–π—Ç–∏–Ω–≥–∞–º–∏
 */

const reviewSchema = new mongoose.Schema({
  // üì¶ –¢–û–í–ê–† –ò –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–¨
  product: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Product',
    required: [true, '–¢–æ–≤–∞—Ä –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω']
  },

  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω']
  },

  order: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Order' // –ü—Ä–∏–≤—è–∑–∫–∞ –∫ –∑–∞–∫–∞–∑—É –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–∫—É–ø–∫–∏
  },

  // ‚≠ê –û–¶–ï–ù–ö–ê
  rating: {
    type: Number,
    required: [true, '–†–µ–π—Ç–∏–Ω–≥ –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω'],
    min: [1, '–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–µ–π—Ç–∏–Ω–≥ - 1'],
    max: [5, '–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–µ–π—Ç–∏–Ω–≥ - 5']
  },

  // üìù –û–¢–ó–´–í
  title: {
    type: String,
    required: [true, '–ó–∞–≥–æ–ª–æ–≤–æ–∫ –æ—Ç–∑—ã–≤–∞ –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω'],
    trim: true,
    maxlength: [100, '–ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π']
  },

  content: {
    type: String,
    required: [true, '–¢–µ–∫—Å—Ç –æ—Ç–∑—ã–≤–∞ –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω'],
    trim: true,
    minlength: [10, '–û—Ç–∑—ã–≤ —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π'],
    maxlength: [1000, '–û—Ç–∑—ã–≤ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π']
  },

  // üì∑ –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–Ø
  images: [{
    url: { type: String, required: true },
    alt: String,
    order: { type: Number, default: 0 }
  }],

  // üëç –ü–õ–Æ–°–´ –ò –ú–ò–ù–£–°–´
  pros: [String],
  cons: [String],

  // üè∑Ô∏è –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø
  variant: {
    _id: mongoose.Schema.Types.ObjectId,
    name: {
      ru: String,
      uz: String,
      en: String
    },
    type: String,
    value: String
  },

  // üè™ –ê–°–ü–ï–ö–¢–´ –û–¶–ï–ù–ö–ò (–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–µ–π—Ç–∏–Ω–≥)
  aspects: {
    quality: { type: Number, min: 1, max: 5 },      // –ö–∞—á–µ—Å—Ç–≤–æ
    design: { type: Number, min: 1, max: 5 },       // –î–∏–∑–∞–π–Ω
    protection: { type: Number, min: 1, max: 5 },   // –ó–∞—â–∏—Ç–∞
    comfort: { type: Number, min: 1, max: 5 },      // –£–¥–æ–±—Å—Ç–≤–æ
    value: { type: Number, min: 1, max: 5 }         // –°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Ü–µ–Ω–∞/–∫–∞—á–µ—Å—Ç–≤–æ
  },

  // ‚úÖ –ú–û–î–ï–†–ê–¶–ò–Ø
  isApproved: {
    type: Boolean,
    default: false
  },

  moderationStatus: {
    type: String,
    enum: ['pending', 'approved', 'rejected', 'requires_changes'],
    default: 'pending'
  },

  moderatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },

  moderatedAt: Date,

  moderationNotes: String,

  rejectionReason: {
    type: String,
    enum: [
      'inappropriate_content',
      'fake_review',
      'spam',
      'off_topic',
      'duplicate',
      'personal_information',
      'other'
    ]
  },

  // üîç –ü–†–û–í–ï–†–ö–ê –ü–û–î–õ–ò–ù–ù–û–°–¢–ò
  isVerifiedPurchase: {
    type: Boolean,
    default: false
  },

  purchaseVerifiedAt: Date,

  // üëç –ü–û–õ–ï–ó–ù–û–°–¢–¨ –û–¢–ó–´–í–ê
  helpfulVotes: {
    positive: { type: Number, default: 0 },
    negative: { type: Number, default: 0 },
    voters: [{
      user: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
      vote: { type: String, enum: ['positive', 'negative'] },
      votedAt: { type: Date, default: Date.now }
    }]
  },

  // üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê
  views: { type: Number, default: 0 },
  
  // üó£Ô∏è –û–¢–í–ï–¢ –ü–†–û–î–ê–í–¶–ê
  response: {
    content: String,
    respondedBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    respondedAt: Date,
    isPublic: { type: Boolean, default: true }
  },

  // üö® –ñ–ê–õ–û–ë–´
  reports: [{
    user: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    reason: {
      type: String,
      enum: ['spam', 'fake', 'inappropriate', 'offensive', 'other']
    },
    notes: String,
    reportedAt: { type: Date, default: Date.now },
    status: {
      type: String,
      enum: ['pending', 'resolved', 'dismissed'],
      default: 'pending'
    }
  }],

  // üè∑Ô∏è –ú–ï–¢–ö–ò
  tags: [String], // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ç–µ–≥–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—è

  // üåç –õ–û–ö–ê–õ–ò–ó–ê–¶–ò–Ø
  language: {
    type: String,
    enum: ['ru', 'uz', 'en'],
    default: 'ru'
  },

  // üì± –¢–ï–•–ù–ò–ß–ï–°–ö–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø
  userAgent: String,
  ipAddress: String,

  // üîÑ –û–ë–ù–û–í–õ–ï–ù–ò–Ø
  editHistory: [{
    editedAt: { type: Date, default: Date.now },
    changes: mongoose.Schema.Types.Mixed,
    reason: String
  }],

  lastEditedAt: Date,

  // ‚ùå –£–î–ê–õ–ï–ù–ò–ï
  isDeleted: { type: Boolean, default: false },
  deletedAt: Date,
  deletedBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  deletionReason: String

}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// üîç –í–ò–†–¢–£–ê–õ–¨–ù–´–ï –ü–û–õ–Ø
reviewSchema.virtual('helpfulnessRatio').get(function() {
  const total = this.helpfulVotes.positive + this.helpfulVotes.negative;
  return total > 0 ? (this.helpfulVotes.positive / total) : 0;
});

reviewSchema.virtual('totalHelpfulVotes').get(function() {
  return this.helpfulVotes.positive + this.helpfulVotes.negative;
});

reviewSchema.virtual('averageAspectRating').get(function() {
  const aspects = this.aspects;
  if (!aspects) return this.rating;
  
  const values = Object.values(aspects).filter(val => val !== undefined);
  return values.length > 0 ? values.reduce((sum, val) => sum + val, 0) / values.length : this.rating;
});

reviewSchema.virtual('authorName').get(function() {
  if (this.user && this.user.firstName) {
    return `${this.user.firstName} ${this.user.lastName ? this.user.lastName[0] + '.' : ''}`;
  }
  return '–ê–Ω–æ–Ω–∏–º';
});

// üìä –ò–ù–î–ï–ö–°–´
reviewSchema.index({ product: 1, createdAt: -1 });
reviewSchema.index({ user: 1, createdAt: -1 });
reviewSchema.index({ rating: -1 });
reviewSchema.index({ isApproved: 1, moderationStatus: 1 });
reviewSchema.index({ isVerifiedPurchase: 1 });
reviewSchema.index({ 'helpfulVotes.positive': -1 });
reviewSchema.index({ createdAt: -1 });
reviewSchema.index({ product: 1, user: 1 }, { unique: true }); // –û–¥–∏–Ω –æ—Ç–∑—ã–≤ –Ω–∞ —Ç–æ–≤–∞—Ä –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è

// üîß MIDDLEWARE
reviewSchema.pre('save', async function(next) {
  try {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ–∫—É–ø–∫—É —Ç–æ–≤–∞—Ä–∞
    if (this.isNew && this.order) {
      const Order = require('./Order');
      const order = await Order.findById(this.order);
      
      if (order && order.customer.equals(this.user) && order.status === 'delivered') {
        const hasPurchased = order.items.some(item => item.product.equals(this.product));
        this.isVerifiedPurchase = hasPurchased;
        
        if (hasPurchased) {
          this.purchaseVerifiedAt = new Date();
        }
      }
    }

    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ–≥–æ–≤ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—è
    if (this.isModified('content') || this.isModified('title')) {
      this.tags = this.extractTags();
    }

    next();
  } catch (error) {
    next(error);
  }
});

// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–µ–π—Ç–∏–Ω–≥–∞ —Ç–æ–≤–∞—Ä–∞ –ø–æ—Å–ª–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –æ—Ç–∑—ã–≤–∞
reviewSchema.post('save', async function() {
  if (this.isApproved) {
    const Product = require('./Product');
    const product = await Product.findById(this.product);
    if (product) {
      await product.updateRating();
    }
  }
});

// üìà –ú–ï–¢–û–î–´
reviewSchema.methods.extractTags = function() {
  const content = `${this.title} ${this.content}`.toLowerCase();
  const tags = [];

  // –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü–∏–∏
  const keywords = {
    'quality': ['–∫–∞—á–µ—Å—Ç–≤–æ', 'sifat', 'quality'],
    'design': ['–¥–∏–∑–∞–π–Ω', 'dizayn', 'design', '–∫—Ä–∞—Å–∏–≤', 'chiroyli', 'beautiful'],
    'protection': ['–∑–∞—â–∏—Ç–∞', 'himoya', 'protection', '–ø—Ä–æ—á–Ω', 'mustahkam', 'durable'],
    'comfort': ['—É–¥–æ–±–Ω', 'qulay', 'comfortable', 'comfort'],
    'price': ['—Ü–µ–Ω–∞', 'narx', 'price', '–¥—ë—à–µ–≤', 'arzon', 'cheap', '–¥–æ—Ä–æ–≥', 'qimmat', 'expensive'],
    'delivery': ['–¥–æ—Å—Ç–∞–≤–∫–∞', 'yetkazib berish', 'delivery', '–±—ã—Å—Ç—Ä', 'tez', 'fast']
  };

  for (const [tag, words] of Object.entries(keywords)) {
    if (words.some(word => content.includes(word))) {
      tags.push(tag);
    }
  }

  return tags;
};

reviewSchema.methods.vote = async function(userId, voteType) {
  // –ü—Ä–æ–≤–µ—Ä–∫–∞, –≥–æ–ª–æ—Å–æ–≤–∞–ª –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ä–∞–Ω–µ–µ
  const existingVote = this.helpfulVotes.voters.find(voter => 
    voter.user.equals(userId)
  );

  if (existingVote) {
    // –ò–∑–º–µ–Ω–µ–Ω–∏–µ –≥–æ–ª–æ—Å–∞
    if (existingVote.vote !== voteType) {
      this.helpfulVotes[existingVote.vote] -= 1;
      this.helpfulVotes[voteType] += 1;
      existingVote.vote = voteType;
      existingVote.votedAt = new Date();
    }
  } else {
    // –ù–æ–≤—ã–π –≥–æ–ª–æ—Å
    this.helpfulVotes[voteType] += 1;
    this.helpfulVotes.voters.push({
      user: userId,
      vote: voteType
    });
  }

  return await this.save();
};

reviewSchema.methods.addReport = async function(userId, reason, notes) {
  this.reports.push({
    user: userId,
    reason,
    notes
  });

  return await this.save();
};

reviewSchema.methods.respond = async function(content, respondedBy) {
  this.response = {
    content,
    respondedBy,
    respondedAt: new Date()
  };

  return await this.save();
};

// –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –º–µ—Ç–æ–¥—ã
reviewSchema.statics.getProductRating = async function(productId) {
  const result = await this.aggregate([
    { 
      $match: { 
        product: new mongoose.Types.ObjectId(productId),
        isApproved: true 
      }
    },
    {
      $group: {
        _id: null,
        averageRating: { $avg: '$rating' },
        totalReviews: { $sum: 1 },
        ratingDistribution: {
          $push: '$rating'
        }
      }
    }
  ]);

  if (result.length === 0) {
    return {
      averageRating: 0,
      totalReviews: 0,
      distribution: { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 }
    };
  }

  const data = result[0];
  const distribution = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
  
  data.ratingDistribution.forEach(rating => {
    distribution[rating] = (distribution[rating] || 0) + 1;
  });

  return {
    averageRating: Math.round(data.averageRating * 10) / 10,
    totalReviews: data.totalReviews,
    distribution
  };
};

reviewSchema.statics.getPendingReviews = function(limit = 50) {
  return this.find({ moderationStatus: 'pending' })
    .populate('user', 'firstName lastName email')
    .populate('product', 'name images')
    .sort({ createdAt: -1 })
    .limit(limit);
};

module.exports = mongoose.model('Review', reviewSchema);
